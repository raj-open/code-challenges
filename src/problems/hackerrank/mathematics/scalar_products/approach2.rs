/// # Second approach #
///
/// This approach mathematically optimised.
/// We rely on the following observation,
/// that the series is generated via Fibonacci matrices:
///
/// ```
/// F = [[0, 1], [1, 1]]
/// G := F ^ 2
/// v_0 := [0, C]
/// v_n = (F^2)^n v_0 = G^n v_0
/// ```
///
/// Noting that `F` and thereby `G` are symmetric,
/// the inner products can be computed via
///
/// ```
/// < v_i, v_j >
/// = < G^i v_0, G^j v_0 >
/// = < (G^i)^* G^j v_0, v_0 >
/// = < (G^i) G^j v_0, v_0 >
/// = < G^{i+j} v_0, v_0 >
/// ```
///
/// So we only neeed to compute powers of `G`.
/// But what powers?
/// We have to iterate over all
/// `i`, `j` with `1 <= i < j <= n`.
/// Simple mathematics yields
///
/// ```
/// Set {i + j for 1 <= i < j <= n} = [3, 2n-1]
/// ```
///
/// i.e. `[3:2n]` in computer-science notation.
///
/// We compute the powers `G^k`
/// for `k in [3:2n]` via
/// products of powers of the form `G^(2^l)`,
/// relying on the binary representation of each `k`.
///
/// By reorganising the multiplication tasks into a binary tree,
/// the total time complexity for computing powers is O(n).
/// (One can more precisely compute this as lying between n/2 and n)
/// So in total, the time complexity is
///
/// ```
/// O(n) + O(n) = O(n)
/// ```

/// ----------------------------------------------------------------
/// IMPORTS
/// ----------------------------------------------------------------

use std::fmt::Debug;
use std::fmt::Display;
use std::io;
use std::io::Stdin;
use std::io::BufRead;
use std::collections::HashMap;
use std::collections::HashSet;
use std::ops::Add;
use std::ops::Mul;
use std::ops::Rem;
use std::slice::Iter;
use std::str::FromStr;

/// ----------------------------------------------------------------
/// MAIN
/// ----------------------------------------------------------------

/// entry point when used as a script
#[allow(unused)]
fn main() {
    let lines = read_input(&io::stdin());
    let line = lines.iter().nth(0).unwrap();

    let args: Vec<String> = line.split(" ").map(|x| x.to_string()).collect();
    let mut args: Iter<'_, String> = args.iter();

    let c = parse::<i64>(args.next().unwrap());
    let m = parse::<i64>(args.next().unwrap());
    let n = parse::<usize>(args.next().unwrap());

    let num_unique = run(c, m, n);

    println!("{:?}", num_unique);
}

pub fn run(c: i64, m: i64, n: usize) -> usize {
    // sequence generated by symmetric matrix
    let zero: Modulo<i64> = Modulo::new(0, m);
    let one: Modulo<i64> = Modulo::new(1, m);
    let v0 = Vector2([zero, Modulo::new(c, m)]);
    let matrix_f = SymmMatrix2x2 { a: zero, b: one, d: one };
    let matrix_g = matrix_f.pow2();

    // compute system[k] = (_, G^k * v0)
    let system = DynamicalSystem {
        evolution: matrix_g,
        state: v0,
    };
    let n_max = 2 * (n as i64);
    let system_powers = compute_powers(&system, n_max);

    // compute all powers of G:
    let mut values: HashSet<i64> = HashSet::new();
    for k in 3.. n_max {
        // k = i + j
        // compute v := G^k * v_0
        let system_pow_k = system_powers.get(&(k as i64)).unwrap();
        let v = system_pow_k.state;
        // now compute < G^i v_0, G^j v_0 > = < G^k v_0, v_0 > = < v, v_0 >
        let value = Vector2::inner_product(&v, &v0).value;
        values.insert(value);
    }

    return values.len();
}

/// ----------------------------------------------------------------
/// ALGORITHMS
/// ----------------------------------------------------------------

/// computes x^(2^k) for 1 <= k <= n
pub fn power_of_2_powers<T>(x: &T, n: i64) -> HashMap<i64, T>
where
    T: Clone + Mul<Output = T> + BinaryPowers,
{
    let mut results: HashMap<i64, T> = HashMap::new();
    let mut x_pow_2_pow = x.clone();
    results.insert(0, x_pow_2_pow.clone());
    (1.. n).for_each(|k| {
        x_pow_2_pow = x_pow_2_pow.pow2();
        results.insert(k as i64, x_pow_2_pow.clone());
    });
    return results;
}

/// efficiently computes x^k for 0 <= k <= n
/// Uses binary tree structure to avoid redundant computations.
/// Time complexity O(n)
pub fn compute_powers<T>(x: &T, n: i64) -> HashMap<i64, T>
where
    T: Clone + Mul<Output = T> + BinaryPowers,
{
    let mut powers: HashMap<i64, T> = HashMap::new();
    powers.insert(0, x.pow0());

    // in trivial case stop
    if n <= 0 {
        return powers;
    }

    /* -------------------------------- *
     * Find l with 2^(l-1) <= n < 2^l (i.e. n has l digits)
     * NOTE:
     * 2^(l-1) <= n < 2^l
     * <==> l - 1 <= log2(n) < l
     * <==> l - 1 = floor(log2(n))
     * <==> l = floor(log2(n)) + 1
     * -------------------------------- */
    let l = (n as f64).log2().floor() as i64 + 1;

    // compute x^(2^k) for k from 0 to l-1
    let x_pow_2_pow = power_of_2_powers(x, l);

    // now compute along levels of a binary tree
    let powers = (0.. l).fold(
        powers,
        |mut prev, k| {
            let num_leaves = prev.len() as i64;
            let x_pow_2_pow_k = x_pow_2_pow.get(&k).unwrap().clone();
            for (&j, value) in prev.clone().iter() {
                let value_ = x_pow_2_pow_k.clone() * value.clone();
                prev.insert(j + num_leaves, value_);
            };
            return prev;
        }
    );

    return powers;
}

/// ----------------------------------------------------------------
/// STRUCTURES
/// ----------------------------------------------------------------

/// Helper structure for modulo computations
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct Modulo<T>
where
    T: Clone + PartialEq + Eq,
{
    pub value: T,
    pub modulus: T,
}

#[derive(Copy, Clone, Debug)]
pub struct Vector2<T>(pub [T; 2]);

#[derive(Copy, Clone, Debug)]
pub struct SymmMatrix2x2<T> {
    pub a: T,
    pub b: T,
    pub d: T,
}

/// A dynamical system encodes
/// evolution = A
/// state = rho
/// with the assumption that rho = A*rho_0
/// for some initial state rho_0
#[derive(Copy, Clone, Debug)]
pub struct DynamicalSystem<T> {
    pub evolution: SymmMatrix2x2<T>,
    pub state: Vector2<T>,
}

/// ----------------------------------------------------------------
/// TRAITS
/// ----------------------------------------------------------------

pub trait NumberLike<T> {
    fn positive(&self) -> bool;
}

pub trait BinaryPowers {
    fn zerolike(&self) -> Self;
    fn pow0(&self) -> Self;
    fn pow2(&self) -> Self;
}

/// ----------------------------------------------------------------
/// IMPLEMENTATIONS
/// ----------------------------------------------------------------

impl NumberLike<i64> for i64 {
    fn positive(&self) -> bool {
        *self > 0
    }
}

impl BinaryPowers for i64 {
    fn zerolike(&self) -> Self {
        0
    }
    fn pow0(&self) -> Self {
        1
    }
    fn pow2(&self) -> Self {
        self * self
    }
}

impl<T> Modulo<T>
where
    T: Display + Clone + PartialEq + Eq,
{
    pub fn new(value: T, modulus: T) -> Self {
        Self { value, modulus }
    }
}

impl<T> Modulo<T>
where
    T: Copy + Clone + PartialEq + Eq + NumberLike<T> + Rem<Output = T>,
{
    // type Output = T;
    // fn rem(self, rhs: Self) -> Self::Output {
    // }

    pub fn remainder(mut self) -> Self {
        let m = self.modulus;
        if m.positive() {
            self.value = self.value.rem(m)
        }
        return self;
    }
}

impl<T> Display for Modulo<T>
where
    T: Display + Clone + PartialEq + Eq,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} (mod {})", self.value, self.modulus)
    }
}

impl<T> Debug for Modulo<T>
where
    T: Display + Clone + PartialEq + Eq,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

impl<T> Add for Modulo<T>
where
    T: Display
        + Copy
        + Clone
        + PartialEq
        + Eq
        + NumberLike<T>
        + Add<Output = T>
        + Rem<Output = T>,
{
    type Output = Self;

    fn add(self, other: Self) -> Self::Output {
        let modulus = self.modulus;
        let value = self.value + other.value;
        return Self::new(value, modulus).remainder();
    }
}

impl<T> Mul for Modulo<T>
where
    T: Display
        + Copy
        + Clone
        + PartialEq
        + Eq
        + NumberLike<T>
        + Mul<Output = T>
        + Rem<Output = T>,
{
    type Output = Self;

    fn mul(self, other: Self) -> Self::Output {
        let modulus = self.modulus;
        let value = self.value * other.value;
        return Self::new(value, modulus).remainder();
    }
}

impl<T> BinaryPowers for Modulo<T>
where
    T: Copy
        + Clone
        + PartialEq
        + Eq
        + NumberLike<T>
        + Mul<Output = T>
        + Rem<Output = T>
        + BinaryPowers,
{
    fn zerolike(&self) -> Self {
        let value = self.value.zerolike();
        let modulus = self.modulus;
        Self { value, modulus }
    }

    fn pow0(&self) -> Self {
        let value = self.value.pow0();
        let modulus = self.modulus;
        Self { value, modulus }
    }

    fn pow2(&self) -> Self {
        let modulus = self.modulus;
        let value = self.value.pow2().rem(modulus);
        Self { value, modulus }
    }
}

impl<T> Vector2<T>
where
    T: Copy,
{
    fn get(&self, index: usize) -> T {
        self.0[index]
    }
}

impl<T> Vector2<T>
where
    T: Copy + Clone + Mul<Output = T> + Add<Output = T>,
{
    fn inner_product(u: &Self, v: &Self) -> T {
        u.get(0) * v.get(0) + u.get(1) * v.get(1)
    }
}

impl<T> SymmMatrix2x2<T>
where
    T: Copy + Mul<Output = T> + Add<Output = T>,
{
    fn mul_vector(&self, u: &Vector2<T>) -> Vector2<T> {
        Vector2(
            [
                (self.a * u.get(0) + self.b * u.get(1)),
                (self.b * u.get(0) + self.d * u.get(1)),
            ],
        )
    }
}

impl<T> Add for SymmMatrix2x2<T>
where
    T: Clone + Add<Output = T>,
{
    type Output = Self;

    fn add(self, other: Self) -> Self::Output {
        Self {
            a: self.a + other.a,
            b: self.b + other.b,
            d: self.d + other.d,
        }
    }
}

impl<T> Mul for SymmMatrix2x2<T>
where
    T: Clone + Mul<Output = T>,
{
    type Output = Self;

    fn mul(self, other: Self) -> Self::Output {
        Self {
            a: self.a * other.a,
            b: self.b * other.b,
            d: self.d * other.d,
        }
    }
}

impl<T> BinaryPowers for SymmMatrix2x2<T>
where
    T: Copy + Mul<Output = T> + Add<Output = T> + BinaryPowers,
{
    fn zerolike(&self) -> Self {
        Self {
            a: self.a.pow0(),
            b: self.b.zerolike(),
            d: self.d.pow0(),
        }
    }

    fn pow0(&self) -> Self {
        Self {
            a: self.a.pow0(),
            b: self.b.zerolike(),
            d: self.d.pow0(),
        }
    }

    fn pow2(&self) -> Self {
        let aa = self.a.pow2();
        let bb = self.b.pow2();
        let dd = self.d.pow2();
        let a = aa + bb;
        let b = (self.a + self.d) * self.b;
        let d = bb + dd;
        Self { a, b, d }
    }
}

impl<T> Mul for DynamicalSystem<T>
where
    T: Copy + Add<Output = T> + Mul<Output = T>,
{
    type Output = Self;

    /// Assumes dynamical system 1 and 2 share the same initial state
    /// i.e. D1 = (U1, rho1), D2 = (U2, rho2)
    /// with rho1 = U1*rho0 and rho2 = U2*rho0
    /// where rho0 = a common initial state
    /// The "product" is determined by
    /// application of evolution 1 to state2,
    /// i.e.
    ///
    /// - replace evolution by U1
    /// - replace initial state by rho2
    ///
    /// i.e.
    ///
    /// D1*D2 := (U1, U1 * rho2)
    ///    = (U1, U1 * U2 * rho0)
    fn mul(self, other: Self) -> Self::Output {
        let evolution = self.evolution;
        let state = self.evolution.mul_vector(&other.state);
        return Self { evolution, state };
    }
}

impl<T> BinaryPowers for DynamicalSystem<T>
where
    T: Copy
        + Clone
        + Add<Output = T>
        + Mul<Output = T>
        + BinaryPowers,
{
    fn zerolike(&self) -> Self {
        Self {
            evolution: self.evolution.zerolike(),
            state: self.state,
        }
    }

    fn pow0(&self) -> Self {
        Self {
            evolution: self.evolution.pow0(),
            state: self.state,
        }
    }

    fn pow2(&self) -> Self {
        let mut evolution = self.evolution;
        let state = self.evolution.mul_vector(&self.state);
        evolution = evolution.pow2();
        Self { evolution, state }
    }
}

/// ----------------------------------------------------------------
/// AUXILIARY
/// ----------------------------------------------------------------

/// Obtains input lines from stdin
/// as a vector of strings.
#[allow(unused)]
fn read_input(stream: &Stdin) -> Vec<String> {
    stream.lock().lines().filter_map(Result::ok).collect()
}

#[allow(unused)]
fn parse<T>(text: &String) -> T
where
    T: FromStr,
    <T as FromStr>::Err: Debug,
{
    return text.parse::<T>().unwrap();
}
