/// # Second approach #
///
/// This approach mathematically optimised.
/// We rely on the following observation,
/// that the series is generated via Fibonacci matrices:
///
/// ```
/// F = [[0, 1], [1, 1]]
/// G := F ^ 2
/// v_0 := [0, C]
/// v_n = (F^2)^n v_0 = G^n v_0
/// ```
///
/// Noting that `F` and thereby `G` are symmetric,
/// the inner products can be computed via
///
/// ```
/// < v_i, v_j >
/// = < G^i v_0, G^j v_0 >
/// = < (G^i)^* G^j v_0, v_0 >
/// = < (G^i) G^j v_0, v_0 >
/// = < G^{i+j} v_0, v_0 >
/// ```
///
/// So we only neeed to compute powers of `G`.
/// But what powers?
/// We have to iterate over all
/// `i`, `j` with `1 <= i < j <= n`.
/// Simple mathematics yields
///
/// ```
/// Set {i + j for 1 <= i < j <= n} = [3, 2n-1]
/// ```
///
/// i.e. `[3:2n]` in computer-science notation.
///
/// We compute the powers `G^k`
/// for `k in [3:2n]` via
/// products of powers of the form `G^(2^l)`,
/// relying on the binary representation of each `k`.
/// We thereby only need to compute `floor(log2(2n)) = O(log(n))` powers,
/// and the products of such powers are themselves `O(log(n))`
/// and we do this for `O(n)` entries.
/// So in total, the time complexity is
///
/// ```
/// O(n log(n)^2).
/// ```

/// ----------------------------------------------------------------
/// IMPORTS
/// ----------------------------------------------------------------

use std::collections::HashSet;
use std::fmt::Debug;
use std::fmt::Display;
use std::io;
use std::io::Stdin;
use std::io::BufRead;
use std::ops::Add;
use std::ops::Mul;
use std::ops::Rem;
use std::slice::Iter;
use std::str::FromStr;

/// ----------------------------------------------------------------
/// MAIN
/// ----------------------------------------------------------------

/// entry point when used as a script
#[allow(unused)]
fn main() {
    let lines = read_input(&io::stdin());
    let line = lines.iter().nth(0).unwrap();

    let args: Vec<String> = line.split(" ").map(|x| x.to_string()).collect();
    let mut args: Iter<'_, String> = args.iter();

    let c = parse::<i32>(args.next().unwrap());
    let m = parse::<i32>(args.next().unwrap());
    let n = parse::<usize>(args.next().unwrap());

    let num_unique = run(c, m, n);

    println!("{:?}", num_unique);
}

pub fn run(c: i32, m: i32, n: usize) -> usize {
    // sequence generated by symmetric matrix
    let zero: Modulo<i64> = Modulo::new(0, m as i64);
    let one: Modulo<i64> = Modulo::new(1, m as i64);
    let matrix_f: SymmMatrix2x2<Modulo<i64>> = SymmMatrix2x2 { a: zero, b: one, d: one };

    /* ---- *
     * The n-the entry of the sequence
     * is given by
     * ---- */

    // e is the smalles integer with 2^e >= (2*n)
    let e = (2.0 * (n as f32)).log2().ceil() as i64;

    // compute G[k] = G^(2^k):
    let mut matrix_g = matrix_f.pow2();
    let mut matrices_g = vec![matrix_g.clone()];
    for _ in 1..e {
        matrix_g = matrix_g.pow2();
        matrices_g.push(matrix_g.clone());
    }

    // compute all powers of G:
    let v0 = Vector2([zero, Modulo::new(c as i64, m as i64)]);
    let mut values: HashSet<i64> = HashSet::new();
    for k in 3..(2 * n) {
        // compute v := G^k * v_0 using divide and conquer
        let k_base2 = format!("{:b}", k);
        let places = k_base2
            .chars()
            .rev()
            .enumerate()
            .filter(|(_, d)| *d == '1')
            .map(|(k, _)| k);
        let mut v = v0.clone();
        for j in places {
            v = matrices_g.get(j).unwrap().mul_vector(&v);
        }
        // now compute < G^i v_0, G^j v_0 > = < G^k v_0, v_0 > = < v, v_0 >
        let value = Vector2::inner_product(&v, &v0).value;
        values.insert(value);
    }

    return values.len();
}

/// ----------------------------------------------------------------
/// SECONDARY
/// ----------------------------------------------------------------
#[derive(Clone, Copy, PartialEq, Eq)]
struct Modulo<T>
where
    T: Display + Clone + Copy + PartialEq + Eq,
{
    value: T,
    modulus: T,
}

#[derive(Clone, Debug)]
struct Vector2<T>([T; 2]);

#[derive(Clone, Debug)]
struct SymmMatrix2x2<T> {
    a: T,
    b: T,
    d: T,
}

impl<T> Modulo<T>
where
    T: Display + Clone + Copy + PartialEq + Eq,
{
    fn new(value: T, modulus: T) -> Self {
        Self { value, modulus }
    }
}

impl<T> Display for Modulo<T>
where
    T: Display + Clone + Copy + PartialEq + Eq,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} (mod {})", self.value, self.modulus)
    }
}

impl<T> Debug for Modulo<T>
where
    T: Display + Clone + Copy + PartialEq + Eq,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self)
    }
}

impl<T> Add for Modulo<T>
where
    T: Display
        + Clone
        + Copy
        + PartialEq
        + Eq
        + Add<Output = T>
        + Add<Output = T>
        + Rem<Output = T>,
{
    type Output = Self;

    fn add(self, other: Self) -> Self::Output {
        let modulus = self.modulus;
        Self {
            value: (self.value + other.value) % modulus,
            modulus,
        }
    }
}

impl<T> Mul for Modulo<T>
where
    T: Display
        + Clone
        + Copy
        + PartialEq
        + Eq
        + Mul<Output = T>
        + Add<Output = T>
        + Rem<Output = T>,
{
    type Output = Self;

    fn mul(self, other: Self) -> Self::Output {
        let modulus = self.modulus;
        Self {
            value: (self.value * other.value) % modulus,
            modulus,
        }
    }
}

impl<T> Add for SymmMatrix2x2<T>
where
    T: Copy + Add<Output = T>,
{
    type Output = Self;

    fn add(self, other: Self) -> Self::Output {
        Self {
            a: self.a + other.a,
            b: self.b + other.b,
            d: self.d + other.d,
        }
    }
}

// impl<T> Mul for SymmMatrix2x2<T>
// where
//     T: Copy + Mul<Output = T> + Add<Output = T>,
// {
//     type Output = Self;

//     fn mul(self, other: Self) -> Self::Output {
//         Self {
//             a: self.a * other.a + self.b * other.b,
//             b: self.a * other.b + self.b * other.d,
//             d: self.b * other.b + self.d * other.d,
//         }
//     }
// }

impl<T> Vector2<T>
where
    T: Copy,
{
    fn get(&self, index: usize) -> T {
        self.0[index]
    }
}

impl<T> Vector2<T>
where
    T: Copy + Mul<Output = T> + Add<Output = T>,
{
    fn inner_product(u: &Self, v: &Self) -> T {
        u.get(0) * v.get(0) + u.get(1) * v.get(1)
    }
}

impl<T> SymmMatrix2x2<T>
where
    T: Copy + Mul<Output = T> + Add<Output = T>,
{
    fn pow2(self) -> Self {
        Self {
            a: self.a * self.a + self.b * self.b,
            b: (self.a + self.d) * self.b,
            d: self.b * self.b + self.d * self.d,
        }
    }

    fn mul_vector(&self, u: &Vector2<T>) -> Vector2<T> {
        Vector2(
            [
                (self.a * u.get(0) + self.b * u.get(1)),
                (self.b * u.get(0) + self.d * u.get(1)),
            ],
        )
    }
}

/// ----------------------------------------------------------------
/// AUXILIARY
/// ----------------------------------------------------------------

/// Obtains input lines from stdin
/// as a vector of strings.
#[allow(unused)]
fn read_input(stream: &Stdin) -> Vec<String> {
    stream.lock()
        .lines()
        .filter_map(Result::ok)
        .collect()
}

#[allow(unused)]
fn parse<T>(text: &String) -> T
where
    T: FromStr,
    <T as FromStr>::Err: Debug,
{
    return text.parse::<T>().unwrap();
}
